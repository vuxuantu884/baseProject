{"ast":null,"code":"(function (root) {\n  // Let's borrow a couple of things from Underscore that we'll need\n  // _.each\n  var breaker = {},\n      AP = Array.prototype,\n      OP = Object.prototype,\n      hasOwn = OP.hasOwnProperty,\n      toString = OP.toString,\n      forEach = AP.forEach,\n      indexOf = AP.indexOf,\n      slice = AP.slice;\n\n  var _each = function _each(obj, iterator, context) {\n    var key, i, l;\n\n    if (!obj) {\n      return;\n    }\n\n    if (forEach && obj.forEach === forEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) {\n          return;\n        }\n      }\n    } else {\n      for (key in obj) {\n        if (hasOwn.call(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) {\n            return;\n          }\n        }\n      }\n    }\n  }; // _.isFunction\n\n\n  var _isFunction = function _isFunction(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  }; // _.extend\n\n\n  var _extend = function _extend(obj) {\n    _each(slice.call(arguments, 1), function (source) {\n      var prop;\n\n      for (prop in source) {\n        if (source[prop] !== void 0) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n\n    return obj;\n  }; // $.inArray\n\n\n  var _inArray = function _inArray(elem, arr, i) {\n    var len;\n\n    if (arr) {\n      if (indexOf) {\n        return indexOf.call(arr, elem, i);\n      }\n\n      len = arr.length;\n      i = i ? i < 0 ? Math.max(0, len + i) : i : 0;\n\n      for (; i < len; i++) {\n        // Skip accessing in sparse arrays\n        if (i in arr && arr[i] === elem) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }; // And some jQuery specific helpers\n\n\n  var class2type = {}; // Populate the class2type map\n\n  _each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function (name, i) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  var _type = function _type(obj) {\n    return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\";\n  }; // Now start the jQuery-cum-Underscore implementation. Some very\n  // minor changes to the jQuery source to get this working.\n  // Internal Deferred namespace\n\n\n  var _d = {}; // String to Object options format cache\n\n  var optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache\n\n  function createOptions(options) {\n    var object = optionsCache[options] = {};\n\n    _each(options.split(/\\s+/), function (flag) {\n      object[flag] = true;\n    });\n\n    return object;\n  }\n\n  _d.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : _extend({}, options);\n\n    var // Last fire value (for non-forgettable lists)\n    memory,\n        // Flag to know if list was already fired\n    _fired,\n        // Flag to know if list is currently firing\n    firing,\n        // First callback to fire (used internally by add and fireWith)\n    firingStart,\n        // End of the loop when firing\n    firingLength,\n        // Index of currently firing callback (modified by remove if needed)\n    firingIndex,\n        // Actual callback list\n    list = [],\n        // Stack of fire calls for repeatable lists\n    stack = !options.once && [],\n        // Fire callbacks\n    fire = function fire(data) {\n      memory = options.memory && data;\n      _fired = true;\n      firingIndex = firingStart || 0;\n      firingStart = 0;\n      firingLength = list.length;\n      firing = true;\n\n      for (; list && firingIndex < firingLength; firingIndex++) {\n        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n          memory = false; // To prevent further calls using add\n\n          break;\n        }\n      }\n\n      firing = false;\n\n      if (list) {\n        if (stack) {\n          if (stack.length) {\n            fire(stack.shift());\n          }\n        } else if (memory) {\n          list = [];\n        } else {\n          self.disable();\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function add() {\n        if (list) {\n          // First, we save the current length\n          var start = list.length;\n\n          (function add(args) {\n            _each(args, function (arg) {\n              var type = _type(arg);\n\n              if (type === \"function\") {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && type !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments); // Do we need to add the callbacks to the\n          // current firing batch?\n\n\n          if (firing) {\n            firingLength = list.length; // With memory, if we're not firing then\n            // we should call right away\n          } else if (memory) {\n            firingStart = start;\n            fire(memory);\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function remove() {\n        if (list) {\n          _each(arguments, function (arg) {\n            var index;\n\n            while ((index = _inArray(arg, list, index)) > -1) {\n              list.splice(index, 1); // Handle firing indexes\n\n              if (firing) {\n                if (index <= firingLength) {\n                  firingLength--;\n                }\n\n                if (index <= firingIndex) {\n                  firingIndex--;\n                }\n              }\n            }\n          });\n        }\n\n        return this;\n      },\n      // Control if a given callback is in the list\n      has: function has(fn) {\n        return _inArray(fn, list) > -1;\n      },\n      // Remove all callbacks from the list\n      empty: function empty() {\n        list = [];\n        return this;\n      },\n      // Have the list do nothing anymore\n      disable: function disable() {\n        list = stack = memory = undefined;\n        return this;\n      },\n      // Is it disabled?\n      disabled: function disabled() {\n        return !list;\n      },\n      // Lock the list in its current state\n      lock: function lock() {\n        stack = undefined;\n\n        if (!memory) {\n          self.disable();\n        }\n\n        return this;\n      },\n      // Is it locked?\n      locked: function locked() {\n        return !stack;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function fireWith(context, args) {\n        args = args || [];\n        args = [context, args.slice ? args.slice() : args];\n\n        if (list && (!_fired || stack)) {\n          if (firing) {\n            stack.push(args);\n          } else {\n            fire(args);\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function fire() {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return self;\n  };\n\n  _d.Deferred = function (func) {\n    var tuples = [// action, add listener, listener list, final state\n    [\"resolve\", \"done\", _d.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", _d.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", _d.Callbacks(\"memory\")]],\n        _state = \"pending\",\n        _promise = {\n      state: function state() {\n        return _state;\n      },\n      always: function always() {\n        deferred.done(arguments).fail(arguments);\n        return this;\n      },\n      then: function\n        /* fnDone, fnFail, fnProgress */\n      then() {\n        var fns = arguments;\n        return _d.Deferred(function (newDefer) {\n          _each(tuples, function (tuple, i) {\n            var action = tuple[0],\n                fn = fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n            deferred[tuple[1]](_isFunction(fn) ? function () {\n              var returned;\n\n              try {\n                returned = fn.apply(this, arguments);\n              } catch (e) {\n                newDefer.reject(e);\n                return;\n              }\n\n              if (returned && _isFunction(returned.promise)) {\n                returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n              } else {\n                newDefer[action !== \"notify\" ? 'resolveWith' : action + 'With'](this === deferred ? newDefer : this, [returned]);\n              }\n            } : newDefer[action]);\n          });\n\n          fns = null;\n        }).promise();\n      },\n      // Get a promise for this deferred\n      // If obj is provided, the promise aspect is added to the object\n      promise: function promise(obj) {\n        return obj != null ? _extend(obj, _promise) : _promise;\n      }\n    },\n        deferred = {}; // Keep pipe for back-compat\n\n    _promise.pipe = _promise.then; // Add list-specific methods\n\n    _each(tuples, function (tuple, i) {\n      var list = tuple[2],\n          stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n      _promise[tuple[1]] = list.add; // Handle state\n\n      if (stateString) {\n        list.add(function () {\n          // state = [ resolved | rejected ]\n          _state = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n      } // deferred[ resolve | reject | notify ] = list.fire\n\n\n      deferred[tuple[0]] = list.fire;\n      deferred[tuple[0] + \"With\"] = list.fireWith;\n    }); // Make the deferred a promise\n\n\n    _promise.promise(deferred); // Call given func if any\n\n\n    if (func) {\n      func.call(deferred, deferred);\n    } // All done!\n\n\n    return deferred;\n  }; // Deferred helper\n\n\n  _d.when = function (subordinate\n  /* , ..., subordinateN */\n  ) {\n    var i = 0,\n        resolveValues = _type(subordinate) === 'array' && arguments.length === 1 ? subordinate : slice.call(arguments),\n        length = resolveValues.length,\n        // the count of uncompleted subordinates\n    remaining = length !== 1 || subordinate && _isFunction(subordinate.promise) ? length : 0,\n        // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n    deferred = remaining === 1 ? subordinate : _d.Deferred(),\n        // Update function for both resolve and progress values\n    updateFunc = function updateFunc(i, contexts, values) {\n      return function (value) {\n        contexts[i] = this;\n        values[i] = arguments.length > 1 ? slice.call(arguments) : value;\n\n        if (values === progressValues) {\n          deferred.notifyWith(contexts, values);\n        } else if (! --remaining) {\n          deferred.resolveWith(contexts, values);\n        }\n      };\n    },\n        progressValues,\n        progressContexts,\n        resolveContexts; // add listeners to Deferred subordinates; treat others as resolved\n\n\n    if (length > 1) {\n      progressValues = new Array(length);\n      progressContexts = new Array(length);\n      resolveContexts = new Array(length);\n\n      for (; i < length; i++) {\n        if (resolveValues[i] && _isFunction(resolveValues[i].promise)) {\n          resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n        } else {\n          --remaining;\n        }\n      }\n    } // if we're not waiting on anything, resolve the master\n\n\n    if (!remaining) {\n      deferred.resolveWith(resolveContexts, resolveValues);\n    }\n\n    return deferred.promise();\n  }; // Try exporting as a Common.js Module\n\n\n  if (typeof module !== \"undefined\" && module.exports) {\n    module.exports = _d; // Or mixin to Underscore.js\n  } else if (typeof root._ !== \"undefined\") {\n    root._.mixin(_d); // Or assign it to window._\n\n  } else {\n    root._ = _d;\n  }\n})(this);","map":{"version":3,"sources":["/home/vuxuantu/Desktop/rewarding-platform-client/node_modules/underscore.deferred/underscore.deferred.js"],"names":["root","breaker","AP","Array","prototype","OP","Object","hasOwn","hasOwnProperty","toString","forEach","indexOf","slice","_each","obj","iterator","context","key","i","l","length","call","_isFunction","constructor","apply","_extend","arguments","source","prop","_inArray","elem","arr","len","Math","max","class2type","split","name","toLowerCase","_type","String","_d","optionsCache","createOptions","options","object","flag","Callbacks","memory","fired","firing","firingStart","firingLength","firingIndex","list","stack","once","fire","data","stopOnFalse","shift","self","disable","add","start","args","arg","type","unique","has","push","remove","index","splice","fn","empty","undefined","disabled","lock","locked","fireWith","Deferred","func","tuples","state","promise","always","deferred","done","fail","then","fns","newDefer","tuple","action","returned","e","reject","resolve","progress","notify","pipe","stateString","when","subordinate","resolveValues","remaining","updateFunc","contexts","values","value","progressValues","notifyWith","resolveWith","progressContexts","resolveContexts","module","exports","_","mixin"],"mappings":"AAAA,CAAC,UAASA,IAAT,EAAc;AAEb;AAEA;AACA,MAAIC,OAAO,GAAG,EAAd;AAAA,MACIC,EAAE,GAAGC,KAAK,CAACC,SADf;AAAA,MAEIC,EAAE,GAAGC,MAAM,CAACF,SAFhB;AAAA,MAIIG,MAAM,GAAGF,EAAE,CAACG,cAJhB;AAAA,MAKIC,QAAQ,GAAGJ,EAAE,CAACI,QALlB;AAAA,MAMIC,OAAO,GAAGR,EAAE,CAACQ,OANjB;AAAA,MAOIC,OAAO,GAAGT,EAAE,CAACS,OAPjB;AAAA,MAQIC,KAAK,GAAGV,EAAE,CAACU,KARf;;AAUA,MAAIC,KAAK,GAAG,SAARA,KAAQ,CAAUC,GAAV,EAAeC,QAAf,EAAyBC,OAAzB,EAAmC;AAC7C,QAAIC,GAAJ,EAASC,CAAT,EAAYC,CAAZ;;AAEA,QAAK,CAACL,GAAN,EAAY;AACV;AACD;;AACD,QAAKJ,OAAO,IAAII,GAAG,CAACJ,OAAJ,KAAgBA,OAAhC,EAA0C;AACxCI,MAAAA,GAAG,CAACJ,OAAJ,CAAaK,QAAb,EAAuBC,OAAvB;AACD,KAFD,MAEO,IAAKF,GAAG,CAACM,MAAJ,KAAe,CAACN,GAAG,CAACM,MAAzB,EAAkC;AACvC,WAAMF,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGL,GAAG,CAACM,MAArB,EAA6BF,CAAC,GAAGC,CAAjC,EAAoCD,CAAC,EAArC,EAA0C;AACxC,YAAKA,CAAC,IAAIJ,GAAL,IAAYC,QAAQ,CAACM,IAAT,CAAeL,OAAf,EAAwBF,GAAG,CAACI,CAAD,CAA3B,EAAgCA,CAAhC,EAAmCJ,GAAnC,MAA6Cb,OAA9D,EAAwE;AACtE;AACD;AACF;AACF,KANM,MAMA;AACL,WAAMgB,GAAN,IAAaH,GAAb,EAAmB;AACjB,YAAKP,MAAM,CAACc,IAAP,CAAaP,GAAb,EAAkBG,GAAlB,CAAL,EAA+B;AAC7B,cAAKF,QAAQ,CAACM,IAAT,CAAeL,OAAf,EAAwBF,GAAG,CAACG,GAAD,CAA3B,EAAkCA,GAAlC,EAAuCH,GAAvC,MAAgDb,OAArD,EAA+D;AAC7D;AACD;AACF;AACF;AACF;AACF,GAvBD,CAfa,CAwCb;;;AACA,MAAIqB,WAAW,GAAG,SAAdA,WAAc,CAAUR,GAAV,EAAgB;AAChC,WAAO,CAAC,EAAEA,GAAG,IAAIA,GAAG,CAACS,WAAX,IAA0BT,GAAG,CAACO,IAA9B,IAAsCP,GAAG,CAACU,KAA5C,CAAR;AACD,GAFD,CAzCa,CA6Cb;;;AACA,MAAIC,OAAO,GAAG,SAAVA,OAAU,CAAUX,GAAV,EAAgB;AAE5BD,IAAAA,KAAK,CAAED,KAAK,CAACS,IAAN,CAAYK,SAAZ,EAAuB,CAAvB,CAAF,EAA6B,UAAUC,MAAV,EAAmB;AACnD,UAAIC,IAAJ;;AAEA,WAAMA,IAAN,IAAcD,MAAd,EAAuB;AACrB,YAAKA,MAAM,CAACC,IAAD,CAAN,KAAiB,KAAK,CAA3B,EAA+B;AAC7Bd,UAAAA,GAAG,CAAEc,IAAF,CAAH,GAAcD,MAAM,CAAEC,IAAF,CAApB;AACD;AACF;AACF,KARI,CAAL;;AASA,WAAOd,GAAP;AACD,GAZD,CA9Ca,CA4Db;;;AACA,MAAIe,QAAQ,GAAG,SAAXA,QAAW,CAAUC,IAAV,EAAgBC,GAAhB,EAAqBb,CAArB,EAAyB;AACtC,QAAIc,GAAJ;;AAEA,QAAKD,GAAL,EAAW;AACT,UAAKpB,OAAL,EAAe;AACb,eAAOA,OAAO,CAACU,IAAR,CAAcU,GAAd,EAAmBD,IAAnB,EAAyBZ,CAAzB,CAAP;AACD;;AAEDc,MAAAA,GAAG,GAAGD,GAAG,CAACX,MAAV;AACAF,MAAAA,CAAC,GAAGA,CAAC,GAAGA,CAAC,GAAG,CAAJ,GAAQe,IAAI,CAACC,GAAL,CAAU,CAAV,EAAaF,GAAG,GAAGd,CAAnB,CAAR,GAAiCA,CAApC,GAAwC,CAA7C;;AAEA,aAAQA,CAAC,GAAGc,GAAZ,EAAiBd,CAAC,EAAlB,EAAuB;AACrB;AACA,YAAKA,CAAC,IAAIa,GAAL,IAAYA,GAAG,CAAEb,CAAF,CAAH,KAAaY,IAA9B,EAAqC;AACnC,iBAAOZ,CAAP;AACD;AACF;AACF;;AAED,WAAO,CAAC,CAAR;AACD,GApBD,CA7Da,CAmFb;;;AAEA,MAAIiB,UAAU,GAAG,EAAjB,CArFa,CAuFb;;AACAtB,EAAAA,KAAK,CAAC,0DAA0DuB,KAA1D,CAAgE,GAAhE,CAAD,EAAuE,UAASC,IAAT,EAAenB,CAAf,EAAkB;AAC5FiB,IAAAA,UAAU,CAAE,aAAaE,IAAb,GAAoB,GAAtB,CAAV,GAAwCA,IAAI,CAACC,WAAL,EAAxC;AACD,GAFI,CAAL;;AAIA,MAAIC,KAAK,GAAG,SAARA,KAAQ,CAAUzB,GAAV,EAAgB;AAC1B,WAAOA,GAAG,IAAI,IAAP,GACL0B,MAAM,CAAE1B,GAAF,CADD,GAELqB,UAAU,CAAE1B,QAAQ,CAACY,IAAT,CAAcP,GAAd,CAAF,CAAV,IAAoC,QAFtC;AAGD,GAJD,CA5Fa,CAkGb;AACA;AAEA;;;AACA,MAAI2B,EAAE,GAAG,EAAT,CAtGa,CAuGb;;AACA,MAAIC,YAAY,GAAG,EAAnB,CAxGa,CA0Gb;;AACA,WAASC,aAAT,CAAwBC,OAAxB,EAAkC;AAChC,QAAIC,MAAM,GAAGH,YAAY,CAAEE,OAAF,CAAZ,GAA0B,EAAvC;;AACA/B,IAAAA,KAAK,CAAE+B,OAAO,CAACR,KAAR,CAAe,KAAf,CAAF,EAA0B,UAAUU,IAAV,EAAiB;AAC9CD,MAAAA,MAAM,CAAEC,IAAF,CAAN,GAAiB,IAAjB;AACD,KAFI,CAAL;;AAGA,WAAOD,MAAP;AACD;;AAEDJ,EAAAA,EAAE,CAACM,SAAH,GAAe,UAAUH,OAAV,EAAoB;AAEjC;AACA;AACAA,IAAAA,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GACNF,YAAY,CAAEE,OAAF,CAAZ,IAA2BD,aAAa,CAAEC,OAAF,CADlC,GAERnB,OAAO,CAAE,EAAF,EAAMmB,OAAN,CAFT;;AAIA,QAAI;AACFI,IAAAA,MADF;AAAA,QAEE;AACAC,IAAAA,MAHF;AAAA,QAIE;AACAC,IAAAA,MALF;AAAA,QAME;AACAC,IAAAA,WAPF;AAAA,QAQE;AACAC,IAAAA,YATF;AAAA,QAUE;AACAC,IAAAA,WAXF;AAAA,QAYE;AACAC,IAAAA,IAAI,GAAG,EAbT;AAAA,QAcE;AACAC,IAAAA,KAAK,GAAG,CAACX,OAAO,CAACY,IAAT,IAAiB,EAf3B;AAAA,QAgBE;AACAC,IAAAA,IAAI,GAAG,SAAPA,IAAO,CAAUC,IAAV,EAAiB;AACtBV,MAAAA,MAAM,GAAGJ,OAAO,CAACI,MAAR,IAAkBU,IAA3B;AACAT,MAAAA,MAAK,GAAG,IAAR;AACAI,MAAAA,WAAW,GAAGF,WAAW,IAAI,CAA7B;AACAA,MAAAA,WAAW,GAAG,CAAd;AACAC,MAAAA,YAAY,GAAGE,IAAI,CAAClC,MAApB;AACA8B,MAAAA,MAAM,GAAG,IAAT;;AACA,aAAQI,IAAI,IAAID,WAAW,GAAGD,YAA9B,EAA4CC,WAAW,EAAvD,EAA4D;AAC1D,YAAKC,IAAI,CAAED,WAAF,CAAJ,CAAoB7B,KAApB,CAA2BkC,IAAI,CAAE,CAAF,CAA/B,EAAsCA,IAAI,CAAE,CAAF,CAA1C,MAAsD,KAAtD,IAA+Dd,OAAO,CAACe,WAA5E,EAA0F;AACxFX,UAAAA,MAAM,GAAG,KAAT,CADwF,CACxE;;AAChB;AACD;AACF;;AACDE,MAAAA,MAAM,GAAG,KAAT;;AACA,UAAKI,IAAL,EAAY;AACV,YAAKC,KAAL,EAAa;AACX,cAAKA,KAAK,CAACnC,MAAX,EAAoB;AAClBqC,YAAAA,IAAI,CAAEF,KAAK,CAACK,KAAN,EAAF,CAAJ;AACD;AACF,SAJD,MAIO,IAAKZ,MAAL,EAAc;AACnBM,UAAAA,IAAI,GAAG,EAAP;AACD,SAFM,MAEA;AACLO,UAAAA,IAAI,CAACC,OAAL;AACD;AACF;AACF,KA1CH;AAAA,QA2CE;AACAD,IAAAA,IAAI,GAAG;AACL;AACAE,MAAAA,GAAG,EAAE,eAAW;AACd,YAAKT,IAAL,EAAY;AACV;AACA,cAAIU,KAAK,GAAGV,IAAI,CAAClC,MAAjB;;AACA,WAAC,SAAS2C,GAAT,CAAcE,IAAd,EAAqB;AACpBpD,YAAAA,KAAK,CAAEoD,IAAF,EAAQ,UAAUC,GAAV,EAAgB;AAC3B,kBAAIC,IAAI,GAAG5B,KAAK,CAAE2B,GAAF,CAAhB;;AACA,kBAAKC,IAAI,KAAK,UAAd,EAA2B;AACzB,oBAAK,CAACvB,OAAO,CAACwB,MAAT,IAAmB,CAACP,IAAI,CAACQ,GAAL,CAAUH,GAAV,CAAzB,EAA2C;AACzCZ,kBAAAA,IAAI,CAACgB,IAAL,CAAWJ,GAAX;AACD;AACF,eAJD,MAIO,IAAKA,GAAG,IAAIA,GAAG,CAAC9C,MAAX,IAAqB+C,IAAI,KAAK,QAAnC,EAA8C;AACnD;AACAJ,gBAAAA,GAAG,CAAEG,GAAF,CAAH;AACD;AACF,aAVI,CAAL;AAWD,WAZD,EAYIxC,SAZJ,EAHU,CAgBV;AACA;;;AACA,cAAKwB,MAAL,EAAc;AACZE,YAAAA,YAAY,GAAGE,IAAI,CAAClC,MAApB,CADY,CAEd;AACA;AACC,WAJD,MAIO,IAAK4B,MAAL,EAAc;AACnBG,YAAAA,WAAW,GAAGa,KAAd;AACAP,YAAAA,IAAI,CAAET,MAAF,CAAJ;AACD;AACF;;AACD,eAAO,IAAP;AACD,OA/BI;AAgCL;AACAuB,MAAAA,MAAM,EAAE,kBAAW;AACjB,YAAKjB,IAAL,EAAY;AACVzC,UAAAA,KAAK,CAAEa,SAAF,EAAa,UAAUwC,GAAV,EAAgB;AAChC,gBAAIM,KAAJ;;AACA,mBAAO,CAAEA,KAAK,GAAG3C,QAAQ,CAAEqC,GAAF,EAAOZ,IAAP,EAAakB,KAAb,CAAlB,IAA2C,CAAC,CAAnD,EAAuD;AACrDlB,cAAAA,IAAI,CAACmB,MAAL,CAAaD,KAAb,EAAoB,CAApB,EADqD,CAErD;;AACA,kBAAKtB,MAAL,EAAc;AACZ,oBAAKsB,KAAK,IAAIpB,YAAd,EAA6B;AAC3BA,kBAAAA,YAAY;AACb;;AACD,oBAAKoB,KAAK,IAAInB,WAAd,EAA4B;AAC1BA,kBAAAA,WAAW;AACZ;AACF;AACF;AACF,WAdI,CAAL;AAeD;;AACD,eAAO,IAAP;AACD,OApDI;AAqDL;AACAgB,MAAAA,GAAG,EAAE,aAAUK,EAAV,EAAe;AAClB,eAAO7C,QAAQ,CAAE6C,EAAF,EAAMpB,IAAN,CAAR,GAAuB,CAAC,CAA/B;AACD,OAxDI;AAyDL;AACAqB,MAAAA,KAAK,EAAE,iBAAW;AAChBrB,QAAAA,IAAI,GAAG,EAAP;AACA,eAAO,IAAP;AACD,OA7DI;AA8DL;AACAQ,MAAAA,OAAO,EAAE,mBAAW;AAClBR,QAAAA,IAAI,GAAGC,KAAK,GAAGP,MAAM,GAAG4B,SAAxB;AACA,eAAO,IAAP;AACD,OAlEI;AAmEL;AACAC,MAAAA,QAAQ,EAAE,oBAAW;AACnB,eAAO,CAACvB,IAAR;AACD,OAtEI;AAuEL;AACAwB,MAAAA,IAAI,EAAE,gBAAW;AACfvB,QAAAA,KAAK,GAAGqB,SAAR;;AACA,YAAK,CAAC5B,MAAN,EAAe;AACba,UAAAA,IAAI,CAACC,OAAL;AACD;;AACD,eAAO,IAAP;AACD,OA9EI;AA+EL;AACAiB,MAAAA,MAAM,EAAE,kBAAW;AACjB,eAAO,CAACxB,KAAR;AACD,OAlFI;AAmFL;AACAyB,MAAAA,QAAQ,EAAE,kBAAUhE,OAAV,EAAmBiD,IAAnB,EAA0B;AAClCA,QAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,QAAAA,IAAI,GAAG,CAAEjD,OAAF,EAAWiD,IAAI,CAACrD,KAAL,GAAaqD,IAAI,CAACrD,KAAL,EAAb,GAA4BqD,IAAvC,CAAP;;AACA,YAAKX,IAAI,KAAM,CAACL,MAAD,IAAUM,KAAhB,CAAT,EAAmC;AACjC,cAAKL,MAAL,EAAc;AACZK,YAAAA,KAAK,CAACe,IAAN,CAAYL,IAAZ;AACD,WAFD,MAEO;AACLR,YAAAA,IAAI,CAAEQ,IAAF,CAAJ;AACD;AACF;;AACD,eAAO,IAAP;AACD,OA/FI;AAgGL;AACAR,MAAAA,IAAI,EAAE,gBAAW;AACfI,QAAAA,IAAI,CAACmB,QAAL,CAAe,IAAf,EAAqBtD,SAArB;AACA,eAAO,IAAP;AACD,OApGI;AAqGL;AACAuB,MAAAA,KAAK,EAAE,iBAAW;AAChB,eAAO,CAAC,CAACA,MAAT;AACD;AAxGI,KA5CT;;AAuJA,WAAOY,IAAP;AACD,GAhKD;;AAkKApB,EAAAA,EAAE,CAACwC,QAAH,GAAc,UAAUC,IAAV,EAAiB;AAE7B,QAAIC,MAAM,GAAG,CACT;AACA,KAAE,SAAF,EAAa,MAAb,EAAqB1C,EAAE,CAACM,SAAH,CAAa,aAAb,CAArB,EAAkD,UAAlD,CAFS,EAGT,CAAE,QAAF,EAAY,MAAZ,EAAoBN,EAAE,CAACM,SAAH,CAAa,aAAb,CAApB,EAAiD,UAAjD,CAHS,EAIT,CAAE,QAAF,EAAY,UAAZ,EAAwBN,EAAE,CAACM,SAAH,CAAa,QAAb,CAAxB,CAJS,CAAb;AAAA,QAMEqC,MAAK,GAAG,SANV;AAAA,QAOEC,QAAO,GAAG;AACRD,MAAAA,KAAK,EAAE,iBAAW;AAChB,eAAOA,MAAP;AACD,OAHO;AAIRE,MAAAA,MAAM,EAAE,kBAAW;AACjBC,QAAAA,QAAQ,CAACC,IAAT,CAAe9D,SAAf,EAA2B+D,IAA3B,CAAiC/D,SAAjC;AACA,eAAO,IAAP;AACD,OAPO;AAQRgE,MAAAA,IAAI,EAAE;AAAU;AAAV,aAA6C;AACjD,YAAIC,GAAG,GAAGjE,SAAV;AAEA,eAAOe,EAAE,CAACwC,QAAH,CAAY,UAAUW,QAAV,EAAqB;AAEtC/E,UAAAA,KAAK,CAAEsE,MAAF,EAAU,UAAUU,KAAV,EAAiB3E,CAAjB,EAAqB;AAClC,gBAAI4E,MAAM,GAAGD,KAAK,CAAE,CAAF,CAAlB;AAAA,gBACEnB,EAAE,GAAGiB,GAAG,CAAEzE,CAAF,CADV,CADkC,CAIlC;;AACAqE,YAAAA,QAAQ,CAAEM,KAAK,CAAC,CAAD,CAAP,CAAR,CAAsBvE,WAAW,CAAEoD,EAAF,CAAX,GAEpB,YAAW;AACT,kBAAIqB,QAAJ;;AACA,kBAAI;AAAEA,gBAAAA,QAAQ,GAAGrB,EAAE,CAAClD,KAAH,CAAU,IAAV,EAAgBE,SAAhB,CAAX;AAAyC,eAA/C,CAAgD,OAAMsE,CAAN,EAAQ;AACtDJ,gBAAAA,QAAQ,CAACK,MAAT,CAAgBD,CAAhB;AACA;AACD;;AAED,kBAAKD,QAAQ,IAAIzE,WAAW,CAAEyE,QAAQ,CAACV,OAAX,CAA5B,EAAmD;AACjDU,gBAAAA,QAAQ,CAACV,OAAT,GACGG,IADH,CACSI,QAAQ,CAACM,OADlB,EAEGT,IAFH,CAESG,QAAQ,CAACK,MAFlB,EAGGE,QAHH,CAGaP,QAAQ,CAACQ,MAHtB;AAID,eALD,MAKO;AACLR,gBAAAA,QAAQ,CAAEE,MAAM,KAAK,QAAX,GAAsB,aAAtB,GAAsCA,MAAM,GAAG,MAAjD,CAAR,CAAkE,SAASP,QAAT,GAAoBK,QAApB,GAA+B,IAAjG,EAAuG,CAAEG,QAAF,CAAvG;AACD;AACF,aAjBmB,GAmBpBH,QAAQ,CAAEE,MAAF,CAnBV;AAqBD,WA1BI,CAAL;;AA4BAH,UAAAA,GAAG,GAAG,IAAN;AAED,SAhCM,EAgCJN,OAhCI,EAAP;AAkCD,OA7CO;AA8CR;AACA;AACAA,MAAAA,OAAO,EAAE,iBAAUvE,GAAV,EAAgB;AACvB,eAAOA,GAAG,IAAI,IAAP,GAAcW,OAAO,CAAEX,GAAF,EAAOuE,QAAP,CAArB,GAAwCA,QAA/C;AACD;AAlDO,KAPZ;AAAA,QA2DEE,QAAQ,GAAG,EA3Db,CAF6B,CA+D7B;;AACAF,IAAAA,QAAO,CAACgB,IAAR,GAAehB,QAAO,CAACK,IAAvB,CAhE6B,CAkE7B;;AACA7E,IAAAA,KAAK,CAAEsE,MAAF,EAAU,UAAUU,KAAV,EAAiB3E,CAAjB,EAAqB;AAClC,UAAIoC,IAAI,GAAGuC,KAAK,CAAE,CAAF,CAAhB;AAAA,UACES,WAAW,GAAGT,KAAK,CAAE,CAAF,CADrB,CADkC,CAIlC;;AACAR,MAAAA,QAAO,CAAEQ,KAAK,CAAC,CAAD,CAAP,CAAP,GAAsBvC,IAAI,CAACS,GAA3B,CALkC,CAOlC;;AACA,UAAKuC,WAAL,EAAmB;AACjBhD,QAAAA,IAAI,CAACS,GAAL,CAAS,YAAW;AAClB;AACAqB,UAAAA,MAAK,GAAGkB,WAAR,CAFkB,CAIpB;AACC,SALD,EAKGnB,MAAM,CAAEjE,CAAC,GAAG,CAAN,CAAN,CAAiB,CAAjB,EAAqB4C,OALxB,EAKiCqB,MAAM,CAAE,CAAF,CAAN,CAAa,CAAb,EAAiBL,IALlD;AAMD,OAfiC,CAiBlC;;;AACAS,MAAAA,QAAQ,CAAEM,KAAK,CAAC,CAAD,CAAP,CAAR,GAAuBvC,IAAI,CAACG,IAA5B;AACA8B,MAAAA,QAAQ,CAAEM,KAAK,CAAC,CAAD,CAAL,GAAW,MAAb,CAAR,GAAgCvC,IAAI,CAAC0B,QAArC;AACD,KApBI,CAAL,CAnE6B,CAyF7B;;;AACAK,IAAAA,QAAO,CAACA,OAAR,CAAiBE,QAAjB,EA1F6B,CA4F7B;;;AACA,QAAKL,IAAL,EAAY;AACVA,MAAAA,IAAI,CAAC7D,IAAL,CAAWkE,QAAX,EAAqBA,QAArB;AACD,KA/F4B,CAiG7B;;;AACA,WAAOA,QAAP;AACD,GAnGD,CArRa,CA0Xb;;;AACA9C,EAAAA,EAAE,CAAC8D,IAAH,GAAU,UAAUC;AAAY;AAAtB,IAAkD;AAC1D,QAAItF,CAAC,GAAG,CAAR;AAAA,QACEuF,aAAa,GAAGlE,KAAK,CAACiE,WAAD,CAAL,KAAuB,OAAvB,IAAkC9E,SAAS,CAACN,MAAV,KAAqB,CAAvD,GACdoF,WADc,GACA5F,KAAK,CAACS,IAAN,CAAYK,SAAZ,CAFlB;AAAA,QAGEN,MAAM,GAAGqF,aAAa,CAACrF,MAHzB;AAAA,QAKE;AACAsF,IAAAA,SAAS,GAAGtF,MAAM,KAAK,CAAX,IAAkBoF,WAAW,IAAIlF,WAAW,CAAEkF,WAAW,CAACnB,OAAd,CAA5C,GAAwEjE,MAAxE,GAAiF,CAN/F;AAAA,QAQE;AACAmE,IAAAA,QAAQ,GAAGmB,SAAS,KAAK,CAAd,GAAkBF,WAAlB,GAAgC/D,EAAE,CAACwC,QAAH,EAT7C;AAAA,QAWE;AACA0B,IAAAA,UAAU,GAAG,SAAbA,UAAa,CAAUzF,CAAV,EAAa0F,QAAb,EAAuBC,MAAvB,EAAgC;AAC3C,aAAO,UAAUC,KAAV,EAAkB;AACvBF,QAAAA,QAAQ,CAAE1F,CAAF,CAAR,GAAgB,IAAhB;AACA2F,QAAAA,MAAM,CAAE3F,CAAF,CAAN,GAAcQ,SAAS,CAACN,MAAV,GAAmB,CAAnB,GAAuBR,KAAK,CAACS,IAAN,CAAYK,SAAZ,CAAvB,GAAiDoF,KAA/D;;AACA,YAAID,MAAM,KAAKE,cAAf,EAAgC;AAC9BxB,UAAAA,QAAQ,CAACyB,UAAT,CAAqBJ,QAArB,EAA+BC,MAA/B;AACD,SAFD,MAEO,IAAK,CAAG,GAAEH,SAAV,EAAwB;AAC7BnB,UAAAA,QAAQ,CAAC0B,WAAT,CAAsBL,QAAtB,EAAgCC,MAAhC;AACD;AACF,OARD;AASD,KAtBH;AAAA,QAwBEE,cAxBF;AAAA,QAwBkBG,gBAxBlB;AAAA,QAwBoCC,eAxBpC,CAD0D,CA2B1D;;;AACA,QAAK/F,MAAM,GAAG,CAAd,EAAkB;AAChB2F,MAAAA,cAAc,GAAG,IAAI5G,KAAJ,CAAWiB,MAAX,CAAjB;AACA8F,MAAAA,gBAAgB,GAAG,IAAI/G,KAAJ,CAAWiB,MAAX,CAAnB;AACA+F,MAAAA,eAAe,GAAG,IAAIhH,KAAJ,CAAWiB,MAAX,CAAlB;;AACA,aAAQF,CAAC,GAAGE,MAAZ,EAAoBF,CAAC,EAArB,EAA0B;AACxB,YAAKuF,aAAa,CAAEvF,CAAF,CAAb,IAAsBI,WAAW,CAAEmF,aAAa,CAAEvF,CAAF,CAAb,CAAmBmE,OAArB,CAAtC,EAAuE;AACrEoB,UAAAA,aAAa,CAAEvF,CAAF,CAAb,CAAmBmE,OAAnB,GACGG,IADH,CACSmB,UAAU,CAAEzF,CAAF,EAAKiG,eAAL,EAAsBV,aAAtB,CADnB,EAEGhB,IAFH,CAESF,QAAQ,CAACU,MAFlB,EAGGE,QAHH,CAGaQ,UAAU,CAAEzF,CAAF,EAAKgG,gBAAL,EAAuBH,cAAvB,CAHvB;AAID,SALD,MAKO;AACL,YAAEL,SAAF;AACD;AACF;AACF,KA1CyD,CA4C1D;;;AACA,QAAK,CAACA,SAAN,EAAkB;AAChBnB,MAAAA,QAAQ,CAAC0B,WAAT,CAAsBE,eAAtB,EAAuCV,aAAvC;AACD;;AAED,WAAOlB,QAAQ,CAACF,OAAT,EAAP;AACD,GAlDD,CA3Xa,CA+ab;;;AACA,MAAK,OAAO+B,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,OAA7C,EAAuD;AACrDD,IAAAA,MAAM,CAACC,OAAP,GAAiB5E,EAAjB,CADqD,CAGvD;AACC,GAJD,MAIO,IAAK,OAAOzC,IAAI,CAACsH,CAAZ,KAAkB,WAAvB,EAAqC;AAC1CtH,IAAAA,IAAI,CAACsH,CAAL,CAAOC,KAAP,CAAa9E,EAAb,EAD0C,CAG5C;;AACC,GAJM,MAIA;AACLzC,IAAAA,IAAI,CAACsH,CAAL,GAAS7E,EAAT;AACD;AAEF,CA5bD,EA4bG,IA5bH","sourcesContent":["(function(root){\n\n  // Let's borrow a couple of things from Underscore that we'll need\n\n  // _.each\n  var breaker = {},\n      AP = Array.prototype,\n      OP = Object.prototype,\n\n      hasOwn = OP.hasOwnProperty,\n      toString = OP.toString,\n      forEach = AP.forEach,\n      indexOf = AP.indexOf,\n      slice = AP.slice;\n\n  var _each = function( obj, iterator, context ) {\n    var key, i, l;\n\n    if ( !obj ) {\n      return;\n    }\n    if ( forEach && obj.forEach === forEach ) {\n      obj.forEach( iterator, context );\n    } else if ( obj.length === +obj.length ) {\n      for ( i = 0, l = obj.length; i < l; i++ ) {\n        if ( i in obj && iterator.call( context, obj[i], i, obj ) === breaker ) {\n          return;\n        }\n      }\n    } else {\n      for ( key in obj ) {\n        if ( hasOwn.call( obj, key ) ) {\n          if ( iterator.call( context, obj[key], key, obj) === breaker ) {\n            return;\n          }\n        }\n      }\n    }\n  };\n\n  // _.isFunction\n  var _isFunction = function( obj ) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  };\n\n  // _.extend\n  var _extend = function( obj ) {\n\n    _each( slice.call( arguments, 1), function( source ) {\n      var prop;\n\n      for ( prop in source ) {\n        if ( source[prop] !== void 0 ) {\n          obj[ prop ] = source[ prop ];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // $.inArray\n  var _inArray = function( elem, arr, i ) {\n    var len;\n\n    if ( arr ) {\n      if ( indexOf ) {\n        return indexOf.call( arr, elem, i );\n      }\n\n      len = arr.length;\n      i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n      for ( ; i < len; i++ ) {\n        // Skip accessing in sparse arrays\n        if ( i in arr && arr[ i ] === elem ) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  };\n\n  // And some jQuery specific helpers\n\n  var class2type = {};\n\n  // Populate the class2type map\n  _each(\"Boolean Number String Function Array Date RegExp Object\".split(\" \"), function(name, i) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n  });\n\n  var _type = function( obj ) {\n    return obj == null ?\n      String( obj ) :\n      class2type[ toString.call(obj) ] || \"object\";\n  };\n\n  // Now start the jQuery-cum-Underscore implementation. Some very\n  // minor changes to the jQuery source to get this working.\n\n  // Internal Deferred namespace\n  var _d = {};\n  // String to Object options format cache\n  var optionsCache = {};\n\n  // Convert String-formatted options into Object-formatted ones and store in cache\n  function createOptions( options ) {\n    var object = optionsCache[ options ] = {};\n    _each( options.split( /\\s+/ ), function( flag ) {\n      object[ flag ] = true;\n    });\n    return object;\n  }\n\n  _d.Callbacks = function( options ) {\n\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ?\n      ( optionsCache[ options ] || createOptions( options ) ) :\n      _extend( {}, options );\n\n    var // Last fire value (for non-forgettable lists)\n      memory,\n      // Flag to know if list was already fired\n      fired,\n      // Flag to know if list is currently firing\n      firing,\n      // First callback to fire (used internally by add and fireWith)\n      firingStart,\n      // End of the loop when firing\n      firingLength,\n      // Index of currently firing callback (modified by remove if needed)\n      firingIndex,\n      // Actual callback list\n      list = [],\n      // Stack of fire calls for repeatable lists\n      stack = !options.once && [],\n      // Fire callbacks\n      fire = function( data ) {\n        memory = options.memory && data;\n        fired = true;\n        firingIndex = firingStart || 0;\n        firingStart = 0;\n        firingLength = list.length;\n        firing = true;\n        for ( ; list && firingIndex < firingLength; firingIndex++ ) {\n          if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n            memory = false; // To prevent further calls using add\n            break;\n          }\n        }\n        firing = false;\n        if ( list ) {\n          if ( stack ) {\n            if ( stack.length ) {\n              fire( stack.shift() );\n            }\n          } else if ( memory ) {\n            list = [];\n          } else {\n            self.disable();\n          }\n        }\n      },\n      // Actual Callbacks object\n      self = {\n        // Add a callback or a collection of callbacks to the list\n        add: function() {\n          if ( list ) {\n            // First, we save the current length\n            var start = list.length;\n            (function add( args ) {\n              _each( args, function( arg ) {\n                var type = _type( arg );\n                if ( type === \"function\" ) {\n                  if ( !options.unique || !self.has( arg ) ) {\n                    list.push( arg );\n                  }\n                } else if ( arg && arg.length && type !== \"string\" ) {\n                  // Inspect recursively\n                  add( arg );\n                }\n              });\n            })( arguments );\n            // Do we need to add the callbacks to the\n            // current firing batch?\n            if ( firing ) {\n              firingLength = list.length;\n            // With memory, if we're not firing then\n            // we should call right away\n            } else if ( memory ) {\n              firingStart = start;\n              fire( memory );\n            }\n          }\n          return this;\n        },\n        // Remove a callback from the list\n        remove: function() {\n          if ( list ) {\n            _each( arguments, function( arg ) {\n              var index;\n              while( ( index = _inArray( arg, list, index ) ) > -1 ) {\n                list.splice( index, 1 );\n                // Handle firing indexes\n                if ( firing ) {\n                  if ( index <= firingLength ) {\n                    firingLength--;\n                  }\n                  if ( index <= firingIndex ) {\n                    firingIndex--;\n                  }\n                }\n              }\n            });\n          }\n          return this;\n        },\n        // Control if a given callback is in the list\n        has: function( fn ) {\n          return _inArray( fn, list ) > -1;\n        },\n        // Remove all callbacks from the list\n        empty: function() {\n          list = [];\n          return this;\n        },\n        // Have the list do nothing anymore\n        disable: function() {\n          list = stack = memory = undefined;\n          return this;\n        },\n        // Is it disabled?\n        disabled: function() {\n          return !list;\n        },\n        // Lock the list in its current state\n        lock: function() {\n          stack = undefined;\n          if ( !memory ) {\n            self.disable();\n          }\n          return this;\n        },\n        // Is it locked?\n        locked: function() {\n          return !stack;\n        },\n        // Call all callbacks with the given context and arguments\n        fireWith: function( context, args ) {\n          args = args || [];\n          args = [ context, args.slice ? args.slice() : args ];\n          if ( list && ( !fired || stack ) ) {\n            if ( firing ) {\n              stack.push( args );\n            } else {\n              fire( args );\n            }\n          }\n          return this;\n        },\n        // Call all the callbacks with the given arguments\n        fire: function() {\n          self.fireWith( this, arguments );\n          return this;\n        },\n        // To know if the callbacks have already been called at least once\n        fired: function() {\n          return !!fired;\n        }\n      };\n\n    return self;\n  };\n\n  _d.Deferred = function( func ) {\n\n    var tuples = [\n        // action, add listener, listener list, final state\n        [ \"resolve\", \"done\", _d.Callbacks(\"once memory\"), \"resolved\" ],\n        [ \"reject\", \"fail\", _d.Callbacks(\"once memory\"), \"rejected\" ],\n        [ \"notify\", \"progress\", _d.Callbacks(\"memory\") ]\n      ],\n      state = \"pending\",\n      promise = {\n        state: function() {\n          return state;\n        },\n        always: function() {\n          deferred.done( arguments ).fail( arguments );\n          return this;\n        },\n        then: function( /* fnDone, fnFail, fnProgress */ ) {\n          var fns = arguments;\n\n          return _d.Deferred(function( newDefer ) {\n\n            _each( tuples, function( tuple, i ) {\n              var action = tuple[ 0 ],\n                fn = fns[ i ];\n\n              // deferred[ done | fail | progress ] for forwarding actions to newDefer\n              deferred[ tuple[1] ]( _isFunction( fn ) ?\n\n                function() {\n                  var returned;\n                  try { returned = fn.apply( this, arguments ); } catch(e){\n                    newDefer.reject(e);\n                    return;\n                  }\n\n                  if ( returned && _isFunction( returned.promise ) ) {\n                    returned.promise()\n                      .done( newDefer.resolve )\n                      .fail( newDefer.reject )\n                      .progress( newDefer.notify );\n                  } else {\n                    newDefer[ action !== \"notify\" ? 'resolveWith' : action + 'With']( this === deferred ? newDefer : this, [ returned ] );\n                  }\n                } :\n\n                newDefer[ action ]\n              );\n            });\n\n            fns = null;\n\n          }).promise();\n\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function( obj ) {\n          return obj != null ? _extend( obj, promise ) : promise;\n        }\n      },\n      deferred = {};\n\n    // Keep pipe for back-compat\n    promise.pipe = promise.then;\n\n    // Add list-specific methods\n    _each( tuples, function( tuple, i ) {\n      var list = tuple[ 2 ],\n        stateString = tuple[ 3 ];\n\n      // promise[ done | fail | progress ] = list.add\n      promise[ tuple[1] ] = list.add;\n\n      // Handle state\n      if ( stateString ) {\n        list.add(function() {\n          // state = [ resolved | rejected ]\n          state = stateString;\n\n        // [ reject_list | resolve_list ].disable; progress_list.lock\n        }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n      }\n\n      // deferred[ resolve | reject | notify ] = list.fire\n      deferred[ tuple[0] ] = list.fire;\n      deferred[ tuple[0] + \"With\" ] = list.fireWith;\n    });\n\n    // Make the deferred a promise\n    promise.promise( deferred );\n\n    // Call given func if any\n    if ( func ) {\n      func.call( deferred, deferred );\n    }\n\n    // All done!\n    return deferred;\n  };\n\n  // Deferred helper\n  _d.when = function( subordinate /* , ..., subordinateN */ ) {\n    var i = 0,\n      resolveValues = _type(subordinate) === 'array' && arguments.length === 1 ?\n        subordinate : slice.call( arguments ),\n      length = resolveValues.length,\n\n      // the count of uncompleted subordinates\n      remaining = length !== 1 || ( subordinate && _isFunction( subordinate.promise ) ) ? length : 0,\n\n      // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n      deferred = remaining === 1 ? subordinate : _d.Deferred(),\n\n      // Update function for both resolve and progress values\n      updateFunc = function( i, contexts, values ) {\n        return function( value ) {\n          contexts[ i ] = this;\n          values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n          if( values === progressValues ) {\n            deferred.notifyWith( contexts, values );\n          } else if ( !( --remaining ) ) {\n            deferred.resolveWith( contexts, values );\n          }\n        };\n      },\n\n      progressValues, progressContexts, resolveContexts;\n\n    // add listeners to Deferred subordinates; treat others as resolved\n    if ( length > 1 ) {\n      progressValues = new Array( length );\n      progressContexts = new Array( length );\n      resolveContexts = new Array( length );\n      for ( ; i < length; i++ ) {\n        if ( resolveValues[ i ] && _isFunction( resolveValues[ i ].promise ) ) {\n          resolveValues[ i ].promise()\n            .done( updateFunc( i, resolveContexts, resolveValues ) )\n            .fail( deferred.reject )\n            .progress( updateFunc( i, progressContexts, progressValues ) );\n        } else {\n          --remaining;\n        }\n      }\n    }\n\n    // if we're not waiting on anything, resolve the master\n    if ( !remaining ) {\n      deferred.resolveWith( resolveContexts, resolveValues );\n    }\n\n    return deferred.promise();\n  };\n\n  // Try exporting as a Common.js Module\n  if ( typeof module !== \"undefined\" && module.exports ) {\n    module.exports = _d;\n\n  // Or mixin to Underscore.js\n  } else if ( typeof root._ !== \"undefined\" ) {\n    root._.mixin(_d);\n\n  // Or assign it to window._\n  } else {\n    root._ = _d;\n  }\n\n})(this);\n"]},"metadata":{},"sourceType":"script"}