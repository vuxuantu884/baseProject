{"ast":null,"code":"(function (global, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof module !== 'undefined' && module.exports) {\n    module.exports = factory();\n  } else {\n    global.sha256 = factory();\n  }\n})(this, function () {\n  var sha256 = function sha256(ascii) {\n    function rightRotate(value, amount) {\n      return value >>> amount | value << 32 - amount;\n    }\n\n    ;\n    var mathPow = Math.pow;\n    var maxWord = mathPow(2, 32);\n    var lengthProperty = 'length';\n    var i, j; // Used as a counter across the whole file\n\n    var result = '';\n    var words = [];\n    var asciiBitLength = ascii[lengthProperty] * 8; //* caching results is optional - remove/add slash from front of this line to toggle\n    // Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\n    // (we actually calculate the first 64, but extra values are just ignored)\n\n    var hash = sha256.h = sha256.h || []; // Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\n\n    var k = sha256.k = sha256.k || [];\n    var primeCounter = k[lengthProperty];\n    /*/\r\n    var hash = [], k = [];\r\n    var primeCounter = 0;\r\n    //*/\n\n    var isComposite = {};\n\n    for (var candidate = 2; primeCounter < 64; candidate++) {\n      if (!isComposite[candidate]) {\n        for (i = 0; i < 313; i += candidate) {\n          isComposite[i] = candidate;\n        }\n\n        hash[primeCounter] = mathPow(candidate, .5) * maxWord | 0;\n        k[primeCounter++] = mathPow(candidate, 1 / 3) * maxWord | 0;\n      }\n    }\n\n    ascii += '\\x80'; // Append '1' bit (plus zero padding)\n\n    while (ascii[lengthProperty] % 64 - 56) ascii += '\\x00'; // More zero padding\n\n\n    for (i = 0; i < ascii[lengthProperty]; i++) {\n      j = ascii.charCodeAt(i);\n      if (j >> 8) return; // ASCII check: only accept characters in range 0-255\n\n      words[i >> 2] |= j << (3 - i) % 4 * 8;\n    }\n\n    words[words[lengthProperty]] = asciiBitLength / maxWord | 0;\n    words[words[lengthProperty]] = asciiBitLength; // process each chunk\n\n    for (j = 0; j < words[lengthProperty];) {\n      var w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\n\n      var oldHash = hash; // This is now the \"working hash\", often labelled as variables a...g\n      // (we have to truncate as well, otherwise extra entries at the end accumulate\n\n      hash = hash.slice(0, 8);\n\n      for (i = 0; i < 64; i++) {\n        var i2 = i + j; // Expand the message into 64 words\n        // Used below if \n\n        var w15 = w[i - 15],\n            w2 = w[i - 2]; // Iterate\n\n        var a = hash[0],\n            e = hash[4];\n        var temp1 = hash[7] + (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\n        + (e & hash[5] ^ ~e & hash[6]) // ch\n        + k[i] // Expand the message schedule if needed\n        + (w[i] = i < 16 ? w[i] : w[i - 16] + (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ w15 >>> 3) // s0\n        + w[i - 7] + (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ w2 >>> 10) // s1\n        | 0); // This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\n\n        var temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22) // S0\n        ) + (a & hash[1] ^ a & hash[2] ^ hash[1] & hash[2]); // maj\n\n        hash = [temp1 + temp2 | 0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\n\n        hash[4] = hash[4] + temp1 | 0;\n      }\n\n      for (i = 0; i < 8; i++) {\n        hash[i] = hash[i] + oldHash[i] | 0;\n      }\n    }\n\n    for (i = 0; i < 8; i++) {\n      for (j = 3; j + 1; j--) {\n        var b = hash[i] >> j * 8 & 255;\n        result += (b < 16 ? 0 : '') + b.toString(16);\n      }\n    }\n\n    return result;\n  };\n\n  sha256.code = \"var sha256=function a(b){function c(a,b){return a>>>b|a<<32-b}for(var d,e,f=Math.pow,g=f(2,32),h=\\\"length\\\",i=\\\"\\\",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o={},p=2;64>n;p++)if(!o[p]){for(d=0;313>d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+=\\\"\\\\x80\\\";b[h]%64-56;)b+=\\\"\\\\x00\\\";for(d=0;d<b[h];d++){if(e=b.charCodeAt(d),e>>8)return;j[d>>2]|=e<<(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e<j[h];){var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64>d;d++){var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&l[5]^~v&l[6])+m[d]+(q[d]=16>d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s>>>3)+q[d-7]+(c(t,17)^c(t,19)^t>>>10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&l[1]^u&l[2]^l[1]&l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8>d;d++)l[d]=l[d]+r[d]|0}for(d=0;8>d;d++)for(e=3;e+1;e--){var y=l[d]>>8*e&255;i+=(16>y?0:\\\"\\\")+y.toString(16)}return i};\";\n  return sha256;\n});","map":{"version":3,"sources":["/home/vuxuantu/Desktop/rewarding-platform-client/node_modules/tiny-sha256/index.js"],"names":["global","factory","define","amd","module","exports","sha256","ascii","rightRotate","value","amount","mathPow","Math","pow","maxWord","lengthProperty","i","j","result","words","asciiBitLength","hash","h","k","primeCounter","isComposite","candidate","charCodeAt","w","slice","oldHash","i2","w15","w2","a","e","temp1","temp2","concat","b","toString","code"],"mappings":"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","sourcesContent":["(function (global, factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\tdefine([], factory);\r\n\t} else if (typeof module !== 'undefined' && module.exports){\r\n\t\tmodule.exports = factory();\r\n\t} else {\r\n\t\tglobal.sha256 = factory();\r\n\t}\r\n})(this, function () {\r\n\r\nvar sha256 = function sha256(ascii) {\r\n\tfunction rightRotate(value, amount) {\r\n\t\treturn (value>>>amount) | (value<<(32 - amount));\r\n\t};\r\n\t\r\n\tvar mathPow = Math.pow;\r\n\tvar maxWord = mathPow(2, 32);\r\n\tvar lengthProperty = 'length';\r\n\tvar i, j; // Used as a counter across the whole file\r\n\tvar result = '';\r\n\r\n\tvar words = [];\r\n\tvar asciiBitLength = ascii[lengthProperty]*8;\r\n\t\r\n\t//* caching results is optional - remove/add slash from front of this line to toggle\r\n\t// Initial hash value: first 32 bits of the fractional parts of the square roots of the first 8 primes\r\n\t// (we actually calculate the first 64, but extra values are just ignored)\r\n\tvar hash = sha256.h = sha256.h || [];\r\n\t// Round constants: first 32 bits of the fractional parts of the cube roots of the first 64 primes\r\n\tvar k = sha256.k = sha256.k || [];\r\n\tvar primeCounter = k[lengthProperty];\r\n\t/*/\r\n\tvar hash = [], k = [];\r\n\tvar primeCounter = 0;\r\n\t//*/\r\n\r\n\tvar isComposite = {};\r\n\tfor (var candidate = 2; primeCounter < 64; candidate++) {\r\n\t\tif (!isComposite[candidate]) {\r\n\t\t\tfor (i = 0; i < 313; i += candidate) {\r\n\t\t\t\tisComposite[i] = candidate;\r\n\t\t\t}\r\n\t\t\thash[primeCounter] = (mathPow(candidate, .5)*maxWord)|0;\r\n\t\t\tk[primeCounter++] = (mathPow(candidate, 1/3)*maxWord)|0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tascii += '\\x80'; // Append '1' bit (plus zero padding)\r\n\twhile (ascii[lengthProperty]%64 - 56) ascii += '\\x00'; // More zero padding\r\n\tfor (i = 0; i < ascii[lengthProperty]; i++) {\r\n\t\tj = ascii.charCodeAt(i);\r\n\t\tif (j>>8) return; // ASCII check: only accept characters in range 0-255\r\n\t\twords[i>>2] |= j << ((3 - i)%4)*8;\r\n\t}\r\n\twords[words[lengthProperty]] = ((asciiBitLength/maxWord)|0);\r\n\twords[words[lengthProperty]] = (asciiBitLength)\r\n\t\r\n\t// process each chunk\r\n\tfor (j = 0; j < words[lengthProperty];) {\r\n\t\tvar w = words.slice(j, j += 16); // The message is expanded into 64 words as part of the iteration\r\n\t\tvar oldHash = hash;\r\n\t\t// This is now the \"working hash\", often labelled as variables a...g\r\n\t\t// (we have to truncate as well, otherwise extra entries at the end accumulate\r\n\t\thash = hash.slice(0, 8);\r\n\t\t\r\n\t\tfor (i = 0; i < 64; i++) {\r\n\t\t\tvar i2 = i + j;\r\n\t\t\t// Expand the message into 64 words\r\n\t\t\t// Used below if \r\n\t\t\tvar w15 = w[i - 15], w2 = w[i - 2];\r\n\r\n\t\t\t// Iterate\r\n\t\t\tvar a = hash[0], e = hash[4];\r\n\t\t\tvar temp1 = hash[7]\r\n\t\t\t\t+ (rightRotate(e, 6) ^ rightRotate(e, 11) ^ rightRotate(e, 25)) // S1\r\n\t\t\t\t+ ((e&hash[5])^((~e)&hash[6])) // ch\r\n\t\t\t\t+ k[i]\r\n\t\t\t\t// Expand the message schedule if needed\r\n\t\t\t\t+ (w[i] = (i < 16) ? w[i] : (\r\n\t\t\t\t\t\tw[i - 16]\r\n\t\t\t\t\t\t+ (rightRotate(w15, 7) ^ rightRotate(w15, 18) ^ (w15>>>3)) // s0\r\n\t\t\t\t\t\t+ w[i - 7]\r\n\t\t\t\t\t\t+ (rightRotate(w2, 17) ^ rightRotate(w2, 19) ^ (w2>>>10)) // s1\r\n\t\t\t\t\t)|0\r\n\t\t\t\t);\r\n\t\t\t// This is only used once, so *could* be moved below, but it only saves 4 bytes and makes things unreadble\r\n\t\t\tvar temp2 = (rightRotate(a, 2) ^ rightRotate(a, 13) ^ rightRotate(a, 22)) // S0\r\n\t\t\t\t+ ((a&hash[1])^(a&hash[2])^(hash[1]&hash[2])); // maj\r\n\t\t\t\r\n\t\t\thash = [(temp1 + temp2)|0].concat(hash); // We don't bother trimming off the extra ones, they're harmless as long as we're truncating when we do the slice()\r\n\t\t\thash[4] = (hash[4] + temp1)|0;\r\n\t\t}\r\n\t\t\r\n\t\tfor (i = 0; i < 8; i++) {\r\n\t\t\thash[i] = (hash[i] + oldHash[i])|0;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfor (i = 0; i < 8; i++) {\r\n\t\tfor (j = 3; j + 1; j--) {\r\n\t\t\tvar b = (hash[i]>>(j*8))&255;\r\n\t\t\tresult += ((b < 16) ? 0 : '') + b.toString(16);\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n};\r\n\r\n\r\nsha256.code = \"var sha256=function a(b){function c(a,b){return a>>>b|a<<32-b}for(var d,e,f=Math.pow,g=f(2,32),h=\\\"length\\\",i=\\\"\\\",j=[],k=8*b[h],l=a.h=a.h||[],m=a.k=a.k||[],n=m[h],o={},p=2;64>n;p++)if(!o[p]){for(d=0;313>d;d+=p)o[d]=p;l[n]=f(p,.5)*g|0,m[n++]=f(p,1/3)*g|0}for(b+=\\\"\\\\x80\\\";b[h]%64-56;)b+=\\\"\\\\x00\\\";for(d=0;d<b[h];d++){if(e=b.charCodeAt(d),e>>8)return;j[d>>2]|=e<<(3-d)%4*8}for(j[j[h]]=k/g|0,j[j[h]]=k,e=0;e<j[h];){var q=j.slice(e,e+=16),r=l;for(l=l.slice(0,8),d=0;64>d;d++){var s=q[d-15],t=q[d-2],u=l[0],v=l[4],w=l[7]+(c(v,6)^c(v,11)^c(v,25))+(v&l[5]^~v&l[6])+m[d]+(q[d]=16>d?q[d]:q[d-16]+(c(s,7)^c(s,18)^s>>>3)+q[d-7]+(c(t,17)^c(t,19)^t>>>10)|0),x=(c(u,2)^c(u,13)^c(u,22))+(u&l[1]^u&l[2]^l[1]&l[2]);l=[w+x|0].concat(l),l[4]=l[4]+w|0}for(d=0;8>d;d++)l[d]=l[d]+r[d]|0}for(d=0;8>d;d++)for(e=3;e+1;e--){var y=l[d]>>8*e&255;i+=(16>y?0:\\\"\\\")+y.toString(16)}return i};\";\r\n\r\nreturn sha256;\r\n\r\n});"]},"metadata":{},"sourceType":"script"}